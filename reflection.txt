## Reflection – Docker Microservices Assignment

### What inspired your application idea, and how did you incorporate creativity?

I chose to build a Task Manager because it's simple yet demonstrates core microservice concepts. It's useful, easy to test, and helped me focus on containerization. For the creative enhancement, I simulated horizontal scaling by manually running multiple backend containers, which helped me understand how load balancing works in Docker-based applications.

### What challenges did you face in designing or implementing the microservices architecture without Docker Compose, and how did you address them?

Without Docker Compose, I had to manually manage the networking and environment variables using CLI commands. It was challenging to get the services to communicate using container names (e.g., `mongo-container`). I overcame this by carefully setting up a custom Docker network and verifying connectivity between services using logs and environment variables.

### How did Docker’s features (e.g., networking, volumes, multi-stage builds) make your development process easier or more robust?

Docker’s custom network allowed the backend and database to discover each other without IP addresses. Volumes preserved my MongoDB data between container restarts. Multi-stage builds reduced my image size by separating the build and runtime stages. Docker also made it easy to replicate and scale the backend with a single command.

### How could your application be extended or improved in a production environment?

In production, this app could benefit from:
- Docker Compose or Kubernetes for easier orchestration and scaling.
- NGINX as a reverse proxy/load balancer.
- CI/CD integration for automated builds and testing.
- A frontend (React or HTML/CSS) to visualize tasks.
- Persistent external storage and secure secrets management.

This assignment helped me understand Docker in a real-world context, and I feel more confident deploying microservices manually.
